import qpu_pkg::*;

// ============================================================
// max_tracker.sv  (saturating abs)
// Tracks per-block maximum magnitude proxy:
//   local_max = max(abs(real), abs(imag))
// abs() saturates the two's-complement corner case:
//   abs(-2^(W-1)) => 2^(W-1)-1
// Used by block_precision_core during ACCUM phase.
// ============================================================

module max_tracker #(
    parameter int W = 32
  )(
    input  logic                 clk,
    input  logic                 rst,
  
    input  logic                 valid,   // sample accepted this cycle
    input  logic signed [W-1:0]  in_real,
    input  logic signed [W-1:0]  in_imag,
  
    input  logic                 clear,   // start_block pulse
    output logic        [W-1:0]  max_out   // unsigned magnitude proxy
  );
  
    localparam logic signed [W-1:0] MIN_NEG = {1'b1, {(W-1){1'b0}}}; // -2^(W-1)
    localparam logic        [W-1:0] MAX_POS = {1'b0, {(W-1){1'b1}}}; //  2^(W-1)-1
  
    function automatic logic [W-1:0] abs_sat(input logic signed [W-1:0] x);
      logic [W-1:0] mag;
      begin
        if (x == MIN_NEG) begin
          mag = MAX_POS;
        end else if (x[W-1]) begin
          // safe because x != MIN_NEG here
          mag = logic'(-x);
        end else begin
          mag = logic'(x);
        end
        return mag;
      end
    endfunction
  
    logic [W-1:0] abs_r, abs_i;
    logic [W-1:0] local_max;
  
    always_comb begin
      abs_r = abs_sat(in_real);
      abs_i = abs_sat(in_imag);
      local_max = (abs_r > abs_i) ? abs_r : abs_i;
    end
  
    always_ff @(posedge clk) begin
      if (rst || clear) begin
        max_out <= '0;
      end else if (valid) begin
        if (local_max > max_out)
          max_out <= local_max;
      end
    end
  
  endmodule